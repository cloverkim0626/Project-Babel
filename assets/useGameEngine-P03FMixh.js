import{e as _,r as u,s as i}from"./index-CcaOQPgg.js";const h=()=>{const{user:a}=_(),[w,f]=u.useState({level:1,xp:0,nextLevelXp:100,maxHp:100}),[d,l]=u.useState(0),[c,p]=u.useState([]),[m,v]=u.useState([]);u.useEffect(()=>{if(!a)return;(async()=>{const{data:e}=await i.from("users").select("*").eq("id",a.id).single();if(e){const r=Math.floor(100*Math.pow(1.2,e.level-1));f({level:e.level,xp:e.xp,nextLevelXp:r,maxHp:e.max_hp}),l(e.points)}const{data:n}=await i.from("incorrect_answers").select("*").eq("user_id",a.id);n&&p(n.map(r=>({id:r.id,word:r.word,nextReview:r.next_review_at,level:r.repetition_level})));let s=i.from("refund_requests").select("*").order("created_at",{ascending:!1});a.role==="student"?s=s.eq("user_id",a.id):s=s.eq("status","pending");const{data:o}=await s;o&&v(o.map(r=>({id:r.id,user:"Unknown",amount:r.amount,status:r.status,date:r.created_at})))})()},[a]);const x=async(t,e,n,s)=>{a&&await i.from("users").update({level:t,xp:e,max_hp:n,points:s}).eq("id",a.id)};return{levelSpecs:w,points:d,addXp:t=>{f(e=>{let n=e.xp+t,s=e.level,o=e.maxHp,r=e.nextLevelXp;for(;n>=r;)n-=r,s++,o+=10,r=Math.floor(r*1.2),alert(`ðŸŽ‰ LEVEL UP! You are now Level ${s}.`);return x(s,n,o,d),{level:s,xp:n,nextLevelXp:r,maxHp:o}})},addPoints:t=>{l(e=>{const n=e+t;return a&&i.from("users").update({points:n}).eq("id",a.id).then(),n})},logError:async t=>{if(!a)return;const e=new Date(Date.now()+6e4).toISOString(),s={id:crypto.randomUUID(),word:t,nextReview:e,level:0};p(r=>[...r,s]);const{error:o}=await i.from("incorrect_answers").insert({user_id:a.id,word:t,error_type:"meaning",next_review_at:e,repetition_level:0});o&&console.error("Failed to log error:",o)},getDueRevives:()=>{const t=new Date().toISOString();return c.filter(e=>e.nextReview<=t)},clearRevive:async t=>{c.find(n=>n.id===t)&&(p(n=>n.filter(s=>s.id!==t)),a&&await i.from("incorrect_answers").delete().eq("id",t))},incorrectVault:c,requestRefund:async t=>{if(d<t){alert("Insufficient Points!");return}a&&(l(e=>e-t),alert("Refund Request Sent!"),await i.from("users").update({points:d-t}).eq("id",a.id),await i.from("refund_requests").insert({user_id:a.id,amount:t}))},refundRequests:m,processRefund:async(t,e)=>{await i.from("refund_requests").update({status:e?"approved":"rejected"}).eq("id",t),v(n=>n.map(s=>s.id!==t?s:{...s,status:e?"approved":"rejected"}))}}};export{h as u};
